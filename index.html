<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TIRED OUT - Tournament Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0a0a0a; margin: 0; overflow: hidden; }
        canvas { touch-action: none; }
        .no-select { user-select: none; -webkit-user-select: none; }
        @keyframes bounce-slow { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .animate-bounce-slow { animation: bounce-slow 3s ease-in-out infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Restored Icons (SVG) ---
        const IconTrophy = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>);
        const IconSettings = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>);
        const IconBook = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1-2.5-2.5Z"/><path d="M8 7h6"/><path d="M8 11h8"/></svg>);
        const IconGift = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="8" width="18" height="4" rx="1"/><path d="M12 8V4H7a2 2 0 0 1 0-4 1 1 0 0 1 1 1 1 1 0 0 1 1 1h3z"/><path d="M12 8h5a2 2 0 0 0 0-4 1 1 0 0 0-1 1 1 1 0 0 0-1 1h-3z"/><path d="M7 12v10a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V12"/><path d="M12 8v16"/></svg>);
        const IconSmartphone = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="14" height="20" x="5" y="2" rx="2" ry="2"/><path d="M12 18h.01"/></svg>);
        const IconRefresh = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>);
        const IconShare = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" x2="12" y1="2" y2="15"/></svg>);

        // --- Game Logic ---
        const SNAP_DIST = 0.5;
        const MOBILE_OFFSET_Y = 3.5;
        const LINK_FB = 'https://www.facebook.com/groups/1747360393316932';
        const LINK_SUPPORT = 'https://buy.stripe.com/dRm9AN8IgcrieVbbOT9EI00';
        const COLOR_RUBBER = '#1a1a1a';
        const COLOR_TREAD = '#333333';
        const COLOR_RIM_P1 = '#3b82f6'; 
        const COLOR_RIM_P2 = '#ef4444'; 
        const COLOR_GHOST_VALID = 'rgba(34, 197, 94, 0.6)';
        const COLOR_GHOST_INVALID = 'rgba(239, 68, 68, 0.6)';

        const Game = () => {
            const [gameState, setGameState] = useState('setup');
            const [boardSize, setBoardSize] = useState(10);
            const [pebbleConfig, setPebbleConfig] = useState(1);
            const [boulderConfig, setBoulderConfig] = useState(1);
            const [matchLength, setMatchLength] = useState(3);
            const [showRules, setShowRules] = useState(false);
            const [scores, setScores] = useState({ p1: 0, p2: 0 });
            const [matchWinner, setMatchWinner] = useState(null);
            const [scale, setScale] = useState(30); 
            const [tires, setTires] = useState([]);
            const [currentPlayer, setCurrentPlayer] = useState(1);
            const [p1Inventory, setP1Inventory] = useState({ pebbles: 1, boulders: 1 });
            const [p2Inventory, setP2Inventory] = useState({ pebbles: 1, boulders: 1 });
            const [selectedPiece, setSelectedPiece] = useState('unit'); 
            const [roundWinner, setRoundWinner] = useState(null);
            const [winReason, setWinReason] = useState('');
            const [ghostPos, setGhostPos] = useState(null); 

            const canvasRef = useRef(null);
            const heatMapCanvasRef = useRef(null);
            const radiusMap = { unit: 1.0, pebble: 0.5, boulder: 1.5 };
            const currentRadius = radiusMap[selectedPiece];

            // Responsive Scaling
            useEffect(() => {
                const handleResize = () => {
                    const maxW = Math.min(window.innerWidth - 32, 600);
                    const maxH = window.innerHeight - 340;
                    const safeDim = Math.min(maxW, maxH);
                    setScale(Math.max(Math.floor(safeDim / boardSize), 12));
                };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, [boardSize, gameState]);

            const drawTire = (ctx, x, y, r, playerColor, isGhost = false) => {
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = isGhost ? playerColor : COLOR_RUBBER;
                ctx.fill();
                if (!isGhost) {
                    ctx.strokeStyle = COLOR_TREAD;
                    ctx.lineWidth = r * 0.2;
                    ctx.beginPath(); ctx.arc(x, y, r * 0.85, 0, Math.PI * 2); ctx.stroke();
                }
                ctx.beginPath(); ctx.arc(x, y, r * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = isGhost ? 'rgba(255,255,255,0.3)' : playerColor;
                ctx.fill();
            };

            const isValidPlacement = (x, y, r, currentTires, size) => {
                if (x - r < 0 || x + r > size || y - r < 0 || y + r > size) return false;
                for (const t of currentTires) {
                    const dx = x - t.x; const dy = y - t.y;
                    if (Math.sqrt(dx*dx + dy*dy) < t.r + r - 0.001) return false;
                }
                return true;
            };

            const getSnappedPosition = (rawX, rawY, r) => {
                let bestX = rawX, bestY = rawY, snapped = false, minGap = SNAP_DIST;
                tires.forEach(t => {
                    const d = Math.sqrt((rawX-t.x)**2 + (rawY-t.y)**2);
                    const gap = Math.abs(d - (t.r + r));
                    if (gap < minGap && d > t.r) {
                        const factor = (t.r + r) / d;
                        const sX = t.x + (rawX-t.x)*factor, sY = t.y + (rawY-t.y)*factor;
                        if (isValidPlacement(sX, sY, r, tires.filter(ot => ot !== t), boardSize)) {
                            bestX = sX; bestY = sY; minGap = gap; snapped = true;
                        }
                    }
                });
                return { x: bestX, y: bestY, snapped };
            };

            const startMatch = () => { setScores({p1:0, p2:0}); setMatchWinner(null); startRound(); };
            const startRound = () => { setTires([]); setCurrentPlayer(1); setP1Inventory({pebbles:pebbleConfig, boulders:boulderConfig}); setP2Inventory({pebbles:pebbleConfig, boulders:boulderConfig}); setSelectedPiece('unit'); setRoundWinner(null); setGameState('playing'); };

            const handleRoundEnd = (winnerId, reason) => {
                const nextScores = { ...scores, [winnerId === 1 ? 'p1' : 'p2']: scores[winnerId === 1 ? 'p1' : 'p2'] + 1 };
                setScores(nextScores); setRoundWinner(winnerId); setWinReason(reason);
                const target = Math.ceil(matchLength / 2);
                setGameState(nextScores.p1 >= target || nextScores.p2 >= target ? 'match_over' : 'round_over');
                if (nextScores.p1 >= target || nextScores.p2 >= target) setMatchWinner(nextScores.p1 >= target ? 1 : 2);
            };

            const attemptPlace = () => {
                if (!ghostPos || !ghostPos.valid) return;
                const inv = currentPlayer === 1 ? p1Inventory : p2Inventory;
                if ((selectedPiece === 'pebble' && inv.pebbles <= 0) || (selectedPiece === 'boulder' && inv.boulders <= 0)) return;
                setTires([...tires, { x: ghostPos.x, y: ghostPos.y, r: currentRadius, player: currentPlayer }]);
                const setInv = currentPlayer === 1 ? setP1Inventory : setP2Inventory;
                if (selectedPiece !== 'unit') setInv(prev => ({ ...prev, [selectedPiece === 'pebble' ? 'pebbles' : 'boulders']: prev[selectedPiece === 'pebble' ? 'pebbles' : 'boulders'] - 1 }));
                setGhostPos(null); setCurrentPlayer(currentPlayer === 1 ? 2 : 1);
            };

            const updateGhost = (clientX, clientY, isTouch = false) => {
                const canvas = canvasRef.current; if (!canvas) return;
                const rect = canvas.getBoundingClientRect();
                let rX = (clientX - rect.left) * (canvas.width / rect.width) / scale;
                let rY = (clientY - rect.top) * (canvas.height / rect.height) / scale;
                if (isTouch) rY -= MOBILE_OFFSET_Y;
                const snap = getSnappedPosition(rX, rY, currentRadius);
                setGhostPos({ ...snap, valid: isValidPlacement(snap.x, snap.y, currentRadius, tires, boardSize) });
            };

            // Heatmap Effect
            useEffect(() => {
                if (gameState === 'setup' || !heatMapCanvasRef.current) return;
                const ctx = heatMapCanvasRef.current.getContext('2d');
                const w = boardSize * scale, h = boardSize * scale;
                const img = ctx.createImageData(w, h);
                const d = img.data;
                const tData = tires.map(t => ({ x: t.x * scale, y: t.y * scale, r: t.r * scale }));
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let dist = Math.min(x, w - x, y, h - y);
                        for (const t of tData) {
                            const ds = Math.sqrt((x-t.x)**2 + (y-t.y)**2) - t.r;
                            if (ds < dist) dist = ds;
                        }
                        const uD = dist / scale;
                        let r, g, b;
                        if (uD < 0) { r=26; g=20; b=20; } 
                        else if (uD < 0.5) { r=60; g=20; b=20; } 
                        else if (uD < 1.0) { r=120; g=40; b=40; } 
                        else if (uD < 1.5) { r=160; g=90; b=90; } 
                        else { r=40; g=60; b=45; } 
                        const i = (y * w + x) * 4;
                        d[i] = r; d[i+1] = g; d[i+2] = b; d[i+3] = 255;
                    }
                }
                ctx.putImageData(img, 0, 0);
            }, [tires, boardSize, scale, gameState]);

            // Draw Tires Effect
            useEffect(() => {
                if (gameState === 'setup' || !canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                ctx.clearRect(0, 0, boardSize * scale, boardSize * scale);
                tires.forEach(t => drawTire(ctx, t.x * scale, t.y * scale, t.r * scale, t.player === 1 ? COLOR_RIM_P1 : COLOR_RIM_P2));
                if (ghostPos) {
                    ctx.beginPath(); ctx.arc(ghostPos.x * scale, ghostPos.y * scale, currentRadius * scale, 0, 2 * Math.PI);
                    ctx.strokeStyle = ghostPos.valid ? '#fff' : '#f00';
                    ctx.lineWidth = ghostPos.snapped ? 3 : 1;
                    ctx.stroke();
                    drawTire(ctx, ghostPos.x * scale, ghostPos.y * scale, currentRadius * scale, ghostPos.valid ? COLOR_GHOST_VALID : COLOR_GHOST_INVALID, true);
                }
            }, [tires, ghostPos, currentRadius, scale]);

            useEffect(() => {
                if (gameState !== 'playing') return;
                const timer = setTimeout(() => {
                    const inv = currentPlayer === 1 ? p1Inventory : p2Inventory;
                    const step = 0.5; let can1=0, can2=0, can3=0;
                    for (let y=0; y<=boardSize; y+=step) {
                        for (let x=0; x<=boardSize; x+=step) {
                            let d = Math.min(x, boardSize-x, y, boardSize-y);
                            for (const t of tires) {
                                const ds = Math.sqrt((x-t.x)**2 + (y-t.y)**2)-t.r;
                                if (ds < d) d = ds;
                            }
                            if (d >= 0.5) can1=1; if (d >= 1.0) can2=1; if (d >= 1.5) can3=1;
                        }
                    }
                    if (!can2 && !(inv.pebbles>0 && can1) && !(inv.boulders>0 && can3)) handleRoundEnd(currentPlayer===1?2:1, `Player ${currentPlayer} TIRED OUT!`);
                }, 400);
                return () => clearTimeout(timer);
            }, [tires, currentPlayer]);

            const renderInventory = (pid, inv) => (
                <div className={`flex flex-col gap-2 p-3 rounded-xl border-2 transition-all ${currentPlayer === pid ? 'border-yellow-400 bg-gray-800 scale-105 shadow-xl' : 'border-gray-700 bg-gray-900 opacity-60'}`}>
                    <div className="flex items-center justify-between mb-1">
                        <span className={`font-black text-lg uppercase ${pid === 1 ? 'text-blue-500' : 'text-red-500'}`}>Player {pid}</span>
                        <div className="flex items-center gap-2">
                             <span className="text-xl font-black text-white">{pid === 1 ? scores.p1 : scores.p2}</span>
                             {currentPlayer === pid && <span className="text-[8px] bg-yellow-500 text-black font-bold px-1.5 py-0.5 rounded animate-pulse">ACTIVE</span>}
                        </div>
                    </div>
                    <div className="flex gap-2">
                        {['unit', 'pebble', 'boulder'].map(type => {
                            const qty = type === 'unit' ? 'âˆž' : (type === 'pebble' ? inv.pebbles : inv.boulders);
                            const active = selectedPiece === type && pid === currentPlayer;
                            return (
                                <button key={type} onClick={() => pid === currentPlayer && qty !== 0 && setSelectedPiece(type)}
                                    className={`flex-1 flex flex-col items-center p-2 rounded-lg ${active ? 'bg-gray-700 ring-2 ring-white' : 'bg-gray-950'} ${qty === 0 ? 'opacity-20' : ''}`}>
                                    <div className={`rounded-full border-2 border-gray-800 bg-gray-300 ${type === 'unit' ? 'w-6 h-6' : (type === 'pebble' ? 'w-4 h-4' : 'w-8 h-8')}`} />
                                    <span className="text-[10px] font-bold mt-1 text-gray-400 uppercase">{qty}</span>
                                </button>
                            );
                        })}
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen text-gray-100 flex flex-col items-center justify-center p-2 no-select relative overflow-hidden">
                    {showRules && (
                        <div className="fixed inset-0 z-[100] bg-black/90 backdrop-blur flex items-center justify-center p-4">
                            <div className="bg-neutral-900 border border-neutral-700 rounded-2xl p-6 max-w-sm w-full">
                                <h2 className="text-2xl font-black text-white mb-4 flex items-center gap-2"><IconBook className="w-6 h-6 text-yellow-500"/> RULES</h2>
                                <p className="text-sm text-gray-300 leading-relaxed mb-4">Be the last to park. If you can't place a tire, you are <b>TIRED OUT</b>.</p>
                                <div className="space-y-3 mb-6">
                                    <div className="text-xs bg-neutral-800 p-2 rounded"><b>Street:</b> Infinite supply.</div>
                                    <div className="text-xs bg-neutral-800 p-2 rounded"><b>Off-Road:</b> Big but hard to fit.</div>
                                    <div className="text-xs bg-neutral-800 p-2 rounded"><b>Spare:</b> Tiny gaps only.</div>
                                </div>
                                <button onClick={() => setShowRules(false)} className="w-full py-3 bg-white text-black font-bold rounded-lg hover:bg-gray-200">Got it</button>
                            </div>
                        </div>
                    )}

                    <div className="mb-2 text-center">
                        <h1 className="text-4xl lg:text-5xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-br from-yellow-400 via-orange-500 to-red-600 transform -skew-x-6 drop-shadow-lg">TIRED OUT</h1>
                        {gameState === 'setup' && <p className="text-gray-600 text-[10px] font-mono uppercase tracking-widest mt-1 flex items-center justify-center gap-2"><IconSmartphone className="w-3 h-3"/> Competitive Parking</p>}
                    </div>

                    {gameState === 'setup' ? (
                        <div className="bg-neutral-900 p-8 rounded-3xl border border-neutral-800 w-full max-w-sm shadow-2xl">
                            <h2 className="text-xl font-bold mb-6 flex items-center gap-2 text-white"><IconSettings className="w-5 h-5 text-yellow-500" /> Lot Settings</h2>
                            <div className="space-y-5">
                                <div>
                                    <label className="text-[10px] font-bold text-gray-500 uppercase block mb-2 tracking-widest">Match Length (Best of {matchLength})</label>
                                    <div className="flex bg-neutral-800 rounded-lg p-1 gap-1">
                                        {[1, 3, 5, 7, 9].map(n => (<button key={n} onClick={() => setMatchLength(n)} className={`flex-1 py-2 rounded-md text-xs font-bold ${matchLength === n ? 'bg-yellow-600 text-white' : 'text-gray-600'}`}>{n}</button>))}
                                    </div>
                                </div>
                                <div>
                                    <label className="text-[10px] font-bold text-gray-500 uppercase block mb-2 tracking-widest">Lot Size</label>
                                    <div className="flex bg-neutral-800 rounded-lg p-1 gap-1">
                                        {[10, 15, 20].map(s => (<button key={s} onClick={() => setBoardSize(s)} className={`flex-1 py-2 rounded-md text-xs font-bold ${boardSize === s ? 'bg-neutral-600 text-white' : 'text-gray-600'}`}>{s}x{s}</button>))}
                                    </div>
                                </div>
                                <button onClick={startMatch} className="w-full py-4 bg-gradient-to-r from-yellow-500 to-orange-600 rounded-xl font-black text-black text-lg uppercase italic shadow-xl hover:scale-[1.02] transition-transform active:scale-95">Open The Lot</button>
                                <div className="flex gap-2">
                                    <button onClick={() => setShowRules(true)} className="flex-1 py-3 bg-neutral-800 text-gray-300 text-xs font-bold rounded-xl flex items-center justify-center gap-2"><IconBook className="w-4 h-4"/> Rules</button>
                                    <button onClick={() => window.open(LINK_SUPPORT, '_blank')} className="flex-1 py-3 bg-indigo-900/40 text-indigo-300 border border-indigo-900/60 text-xs font-bold rounded-xl flex items-center justify-center gap-2 hover:bg-indigo-900/60 transition-colors"><IconGift className="w-4 h-4"/> Support</button>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex flex-col lg:flex-row gap-6 items-center">
                            <div className="relative rounded-2xl overflow-hidden border-4 border-neutral-800 bg-neutral-900 shadow-2xl shrink-0" style={{ width: boardSize * scale, height: boardSize * scale }}>
                                <canvas ref={heatMapCanvasRef} width={boardSize * scale} height={boardSize * scale} className="absolute inset-0 opacity-80" />
                                <canvas ref={canvasRef} width={boardSize * scale} height={boardSize * scale} onMouseMove={e => updateGhost(e.clientX, e.clientY)} onTouchMove={e => updateGhost(e.touches[0].clientX, e.touches[0].clientY, true)} onMouseUp={attemptPlace} onTouchEnd={attemptPlace} className="absolute inset-0 z-10 cursor-crosshair touch-none" />
                                
                                {(gameState === 'round_over' || gameState === 'match_over') && (
                                    <div className="absolute inset-0 z-50 bg-neutral-900/95 backdrop-blur-sm flex flex-col items-center justify-center p-6 text-center animate-in zoom-in duration-300">
                                        <IconTrophy className={`w-20 h-20 mb-4 animate-bounce-slow ${gameState === 'match_over' ? 'text-yellow-400' : 'text-gray-400'}`} />
                                        <h2 className="text-3xl font-black text-white italic -skew-x-6 mb-1 uppercase">{gameState === 'match_over' ? 'Match Champion' : 'Round Over'}</h2>
                                        <p className="text-lg text-gray-400 mb-6">{winReason || (matchWinner === 1 ? 'P1 Victory!' : 'P2 Victory!')}</p>
                                        <div className="flex flex-col gap-3 w-full max-w-xs">
                                            {gameState === 'match_over' && (
                                                <button onClick={() => window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(LINK_FB)}`, '_blank')} className="px-6 py-3 bg-[#1877F2] text-white font-bold rounded-full flex items-center justify-center gap-2 shadow-lg"><IconShare className="w-4 h-4"/> Share Result</button>
                                            )}
                                            <button onClick={gameState === 'match_over' ? () => setGameState('setup') : startRound} className="px-8 py-3 bg-white text-black font-black rounded-full uppercase flex items-center justify-center gap-2">{gameState === 'match_over' ? <IconRefresh className="w-4 h-4"/> : null}{gameState === 'match_over' ? 'New Match' : 'Next Round'}</button>
                                        </div>
                                    </div>
                                )}
                            </div>

                            <div className="w-full max-w-sm flex flex-col gap-3 shrink-0">
                                <div className="bg-neutral-800 p-3 rounded-xl flex justify-between items-center text-xs font-bold border border-neutral-700 shadow-lg">
                                    <span className="text-gray-500 uppercase tracking-widest">Match Score</span>
                                    <div className="flex gap-4 font-black">
                                        <span className="text-blue-500">P1: {scores.p1}</span>
                                        <span className="text-gray-500">vs</span>
                                        <span className="text-red-500">P2: {scores.p2}</span>
                                    </div>
                                </div>
                                {renderInventory(1, p1Inventory)}
                                {renderInventory(2, p2Inventory)}
                                <div className="grid grid-cols-4 gap-1 text-[8px] font-mono text-center uppercase tracking-tighter text-gray-500 bg-neutral-900/50 p-2 rounded-lg border border-neutral-800 mt-2">
                                    <div className="flex flex-col items-center gap-1"><div className="w-2 h-2 rounded bg-[#283c2d]" /> Open</div>
                                    <div className="flex flex-col items-center gap-1"><div className="w-2 h-2 rounded bg-[#a05a5a]" /> Tight</div>
                                    <div className="flex flex-col items-center gap-1"><div className="w-2 h-2 rounded bg-[#782828]" /> Spare</div>
                                    <div className="flex flex-col items-center gap-1"><div className="w-2 h-2 rounded bg-[#1a1414]" /> Block</div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>
