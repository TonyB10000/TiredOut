<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TIRED OUT - Mathematical Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0a0a0a; margin: 0; overflow: hidden; }
        canvas { touch-action: none; }
        .no-select { user-select: none; -webkit-user-select: none; }
        @keyframes bounce-slow { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .animate-bounce-slow { animation: bounce-slow 3s ease-in-out infinite; }
        .ai-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const IconTrophy = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>);
        const IconSettings = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>);
        const IconBook = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1-2.5-2.5Z"/><path d="M8 7h6"/><path d="M8 11h8"/></svg>);
        const IconSearch = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>);
        const IconCpu = ({className}) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="16" height="16" x="4" y="4" rx="2"/><rect width="6" height="6" x="9" y="9" rx="1"/><path d="M15 2v2"/><path d="M15 20v2"/><path d="M2 15h2"/><path d="M2 9h2"/><path d="M20 15h2"/><path d="M20 9h2"/><path d="M9 2v2"/><path d="M9 20v2"/></svg>);

        const SNAP_DIST = 0.5;
        const MOBILE_OFFSET_Y = 3.5;
        const COLOR_RIM_P1 = '#3b82f6'; 
        const COLOR_RIM_P2 = '#ef4444'; 

        const Game = () => {
            const [gameState, setGameState] = useState('setup'); 
            const [boardSize, setBoardSize] = useState(10);
            const [pebbleConfig, setPebbleConfig] = useState(1);
            const [boulderConfig, setBoulderConfig] = useState(1);
            const [matchLength, setMatchLength] = useState(3);
            const [opponentType, setOpponentType] = useState('ai'); 
            const [aiToughness, setAiToughness] = useState(5);
            const [showRules, setShowRules] = useState(false);
            const [isAiThinking, setIsAiThinking] = useState(false);
            const [zoomIndex, setZoomIndex] = useState(null); 

            const [scores, setScores] = useState({ p1: 0, p2: 0 });
            const [matchWinner, setMatchWinner] = useState(null);
            const [scale, setScale] = useState(30); 
            const [tires, setTires] = useState([]);
            const [currentPlayer, setCurrentPlayer] = useState(1);
            const [p1Inventory, setP1Inventory] = useState({ pebbles: 1, boulders: 1 });
            const [p2Inventory, setP2Inventory] = useState({ pebbles: 1, boulders: 1 });
            const [selectedPiece, setSelectedPiece] = useState('unit'); 
            const [winReason, setWinReason] = useState('');
            const [ghostPos, setGhostPos] = useState(null); 
            const [regionCounts, setRegionCounts] = useState({ spare: 0, street: 0, offroad: 0 });
            
            const canvasRef = useRef(null);
            const heatMapCanvasRef = useRef(null);
            const radiusMap = { unit: 1.0, pebble: 0.5, boulder: 1.5 };
            const currentRadius = radiusMap[selectedPiece];

            const getZoomOffset = (idx) => {
                if (idx === null) return { x: 0, y: 0, factor: 1 };
                const half = boardSize / 2;
                const quarter = boardSize / 4;
                const mapping = {
                    1: { x: 0, y: 0 }, 2: { x: quarter, y: 0 }, 3: { x: half, y: 0 },
                    4: { x: 0, y: quarter }, 5: { x: quarter, y: quarter }, 6: { x: half, y: quarter },
                    7: { x: 0, y: half }, 8: { x: quarter, y: half }, 9: { x: half, y: half }
                };
                return { ...mapping[idx], factor: 2 };
            };

            const view = useMemo(() => getZoomOffset(zoomIndex), [zoomIndex, boardSize]);

            useEffect(() => {
                const handleResize = () => {
                    const safeDim = Math.min(window.innerWidth - 32, window.innerHeight - 440);
                    setScale(Math.max(Math.floor(safeDim / (boardSize / view.factor)), 12));
                };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, [boardSize, gameState, view]);

            const getClearance = (x, y, currentTires) => {
                let minDist = Math.min(x, y, boardSize - x, boardSize - y);
                if (minDist < 0) return -1;
                for (const t of currentTires) {
                    const d = Math.sqrt((x - t.x) ** 2 + (y - t.y) ** 2) - t.r;
                    if (d < minDist) minDist = d;
                }
                return minDist;
            };

            const checkPlayerHasMove = (pid, inv, currentTires) => {
                const step = 0.5; 
                for (let y = 0; y <= boardSize; y += step) {
                    for (let x = 0; x <= boardSize; x += step) {
                        const clear = getClearance(x, y, currentTires);
                        if (clear >= 1.0) return true;
                        if (inv.pebbles > 0 && clear >= 0.5) return true;
                        if (inv.boulders > 0 && clear >= 1.5) return true;
                    }
                }
                return false;
            };

            const findMaxClearance = (pieceType, currentTires) => {
                const r = radiusMap[pieceType];
                const seedCount = aiToughness * 6; 
                const iterations = aiToughness * 12;
                let bestFound = { x: boardSize/2, y: boardSize/2, val: -1 };

                for (let i = 0; i < seedCount; i++) {
                    let cx = Math.random() * boardSize;
                    let cy = Math.random() * boardSize;
                    let ds = boardSize / 2;

                    for (let j = 0; j < iterations; j++) {
                        let foundBetter = false;
                        let bestLocalVal = getClearance(cx, cy, currentTires);
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                            const nx = cx + Math.cos(angle) * ds;
                            const ny = cy + Math.sin(angle) * ds;
                            if (nx < r || nx > boardSize - r || ny < r || ny > boardSize - r) continue;
                            const val = getClearance(nx, ny, currentTires);
                            if (val > bestLocalVal) {
                                bestLocalVal = val; cx = nx; cy = ny; foundBetter = true;
                            }
                        }
                        if (!foundBetter) ds *= 0.6;
                    }
                    const finalVal = getClearance(cx, cy, currentTires);
                    if (finalVal > bestFound.val) {
                        bestFound = { x: cx, y: cy, val: finalVal };
                    }
                }
                return bestFound;
            };

            const solveAiTurn = () => {
                setIsAiThinking(true);
                setTimeout(() => {
                    const inv = p2Inventory;
                    let bestPiece = 'unit';
                    const boulderSpot = findMaxClearance('boulder', tires);
                    if (inv.boulders > 0 && boulderSpot.val >= 1.5) {
                        bestPiece = 'boulder';
                    } else {
                        const unitSpot = findMaxClearance('unit', tires);
                        if (unitSpot.val >= 1.0) {
                            bestPiece = 'unit';
                        } else if (inv.pebbles > 0) {
                            bestPiece = 'pebble';
                        }
                    }
                    const spot = findMaxClearance(bestPiece, tires);
                    if (spot.val < radiusMap[bestPiece]) {
                        handleRoundEnd(1, "AI is TIRED OUT!");
                    } else {
                        setTires(prev => [...prev, { x: spot.x, y: spot.y, r: radiusMap[bestPiece], player: 2 }]);
                        const setInv = setP2Inventory;
                        if (bestPiece !== 'unit') setInv(prev => ({ ...prev, [bestPiece === 'pebble' ? 'pebbles' : 'boulders']: prev[bestPiece === 'pebble' ? 'pebbles' : 'boulders'] - 1 }));
                        setCurrentPlayer(1);
                    }
                    setIsAiThinking(false);
                }, 800);
            };

            const startMatch = () => { setScores({ p1: 0, p2: 0 }); setMatchWinner(null); startRound(); };
            const startRound = () => { 
                setTires([]); 
                setCurrentPlayer(1); 
                setP1Inventory({ pebbles: pebbleConfig, boulders: boulderConfig }); 
                setP2Inventory({ pebbles: pebbleConfig, boulders: boulderConfig }); 
                setSelectedPiece('unit'); 
                setGameState('playing'); 
                setWinReason(''); 
                setZoomIndex(null);
            };

            const handleRoundEnd = (winnerId, reason) => {
                const newScores = { ...scores, [winnerId === 1 ? 'p1' : 'p2']: scores[winnerId === 1 ? 'p1' : 'p2'] + 1 };
                setScores(newScores);
                setWinReason(reason);
                const target = Math.ceil(matchLength / 2);
                if (newScores.p1 >= target || newScores.p2 >= target) {
                    setMatchWinner(newScores.p1 >= target ? 1 : 2);
                    setGameState('match_over');
                } else {
                    setGameState('round_over');
                }
            };

            const attemptPlace = () => {
                if (isAiThinking || (currentPlayer === 2 && opponentType === 'ai')) return;
                if (!ghostPos || !ghostPos.valid) return;
                const newTires = [...tires, { x: ghostPos.x, y: ghostPos.y, r: currentRadius, player: currentPlayer }];
                setTires(newTires);
                if (selectedPiece !== 'unit') {
                    const setInv = currentPlayer === 1 ? setP1Inventory : setP2Inventory;
                    setInv(prev => ({ ...prev, [selectedPiece === 'pebble' ? 'pebbles' : 'boulders']: prev[selectedPiece === 'pebble' ? 'pebbles' : 'boulders'] - 1 }));
                }
                setGhostPos(null);
                setCurrentPlayer(currentPlayer === 1 ? 2 : 1);
            };

            useEffect(() => {
                if (gameState !== 'playing' || isAiThinking) return;
                const inv = currentPlayer === 1 ? p1Inventory : p2Inventory;
                if (!checkPlayerHasMove(currentPlayer, inv, tires)) {
                    handleRoundEnd(currentPlayer === 1 ? 2 : 1, `Player ${currentPlayer} has no moves left!`);
                } else if (currentPlayer === 2 && opponentType === 'ai') {
                    solveAiTurn();
                }
            }, [currentPlayer, tires, gameState]);

            const updateGhost = (clientX, clientY, isTouch = false) => {
                if (isAiThinking || (currentPlayer === 2 && opponentType === 'ai')) return;
                const canvas = canvasRef.current; if (!canvas) return;
                const rect = canvas.getBoundingClientRect();
                
                let rawX = (clientX - rect.left) * (canvas.width / rect.width) / scale;
                let rawY = (clientY - rect.top) * (canvas.height / rect.height) / scale;
                if (isTouch) rawY -= MOBILE_OFFSET_Y;

                let rX = rawX + view.x;
                let rY = rawY + view.y;

                let bX = rX, bY = rY, snapped = false, minGap = SNAP_DIST;
                tires.forEach(t => {
                    const d = Math.sqrt((rX-t.x)**2 + (rY-t.y)**2);
                    const gap = Math.abs(d - (t.r + currentRadius));
                    if (gap < minGap && d > t.r) {
                        const f = (t.r + currentRadius) / d;
                        const sX = t.x + (rX-t.x)*f, sY = t.y + (rY-t.y)*f;
                        if (getClearance(sX, sY, tires.filter(ot => ot !== t)) >= currentRadius - 0.001) {
                            bX = sX; bY = sY; minGap = gap; snapped = true;
                        }
                    }
                });
                setGhostPos({ x: bX, y: bY, snapped, valid: getClearance(bX, bY, tires) >= currentRadius - 0.001 });
            };

            useEffect(() => {
                if (gameState === 'setup' || !heatMapCanvasRef.current) return;
                const ctx = heatMapCanvasRef.current.getContext('2d');
                const w = (boardSize / view.factor) * scale;
                const h = (boardSize / view.factor) * scale;
                const img = ctx.createImageData(w, h);
                const d = img.data;

                let counts = { spare: 0, street: 0, offroad: 0 };

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const worldX = (x / scale) + view.x;
                        const worldY = (y / scale) + view.y;
                        const clear = getClearance(worldX, worldY, tires);
                        let r, g, b;
                        if (clear < 0) { r=20; g=10; b=10; } 
                        else if (clear < 0.5) { r=60; g=20; b=20; } 
                        else if (clear < 1.0) { r=100; g=40; b=40; counts.spare++; } 
                        else if (clear < 1.5) { r=140; g=80; b=80; counts.street++; } 
                        else { r=30; g=50; b=35; counts.offroad++; } 
                        const i = (y * w + x) * 4;
                        d[i] = r; d[i+1] = g; d[i+2] = b; d[i+3] = 255;
                    }
                }
                ctx.putImageData(img, 0, 0);
                setRegionCounts(counts);
            }, [tires, boardSize, scale, gameState, view]);

            useEffect(() => {
                if (gameState === 'setup' || !canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                ctx.clearRect(0, 0, (boardSize / view.factor) * scale, (boardSize / view.factor) * scale);
                tires.forEach(t => {
                    const screenX = (t.x - view.x) * scale;
                    const screenY = (t.y - view.y) * scale;
                    const screenR = t.r * scale;
                    
                    ctx.beginPath(); ctx.arc(screenX, screenY, screenR, 0, Math.PI * 2);
                    ctx.fillStyle = '#111'; ctx.fill();
                    ctx.beginPath(); ctx.arc(screenX, screenY, screenR * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = t.player === 1 ? COLOR_RIM_P1 : COLOR_RIM_P2; ctx.fill();
                });
                if (ghostPos) {
                    const gx = (ghostPos.x - view.x) * scale;
                    const gy = (ghostPos.y - view.y) * scale;
                    ctx.beginPath(); ctx.arc(gx, gy, currentRadius * scale, 0, 2 * Math.PI);
                    ctx.strokeStyle = ghostPos.valid ? '#fff' : '#f00';
                    ctx.lineWidth = ghostPos.snapped ? 3 : 1; ctx.stroke();
                }
            }, [tires, ghostPos, currentRadius, scale, gameState, view]);

            const getFinalMessage = () => {
                if (gameState !== 'match_over') return winReason;
                const levelStr = aiToughness === 10 ? 'ELITE' : aiToughness;
                if (opponentType === 'ai') {
                    return matchWinner === 1 
                        ? `You beat the bot at level ${levelStr}!!` 
                        : `The bot beat you at level ${levelStr}...`;
                }
                return matchWinner === 1 ? 'Player 1 Wins the Match!' : 'Player 2 Wins the Match!';
            };

            return (
                <div className="min-h-screen text-gray-100 flex flex-col items-center justify-center p-2 no-select relative overflow-hidden bg-black">
                    {showRules && (
                        <div className="fixed inset-0 z-[100] bg-black/90 backdrop-blur flex items-center justify-center p-4">
                            <div className="bg-neutral-900 border border-neutral-700 rounded-2xl p-6 max-w-lg w-full shadow-2xl overflow-y-auto max-h-[90vh]">
                                <h2 className="text-2xl font-black text-white mb-4 flex items-center gap-2 uppercase italic"><IconBook className="w-6 h-6 text-yellow-500"/> How to Play</h2>
                                <div className="space-y-4 text-sm text-gray-300 leading-relaxed">
                                    <p><b>Objective:</b> Be the last player to park a tire. If you have no room left to place any of your available tires, you are <b>TIRED OUT</b> and lose the round.</p>
                                    
                                    <div className="bg-black/30 p-3 rounded-lg border border-white/5">
                                        <h3 className="text-white font-bold mb-1">The Tires:</h3>
                                        <ul className="list-disc ml-4 space-y-1 text-xs">
                                            <li><b className="text-blue-400">Street (∞):</b> Your standard piece. You never run out.</li>
                                            <li><b className="text-green-400">Off-Road:</b> Large tires. Great for taking up space quickly.</li>
                                            <li><b className="text-red-400">Spare:</b> Small tires. Use these to squeeze into tiny gaps near the end of the game.</li>
                                        </ul>
                                    </div>

                                    <div className="bg-black/30 p-3 rounded-lg border border-white/5">
                                        <h3 className="text-white font-bold mb-1">Advanced Features:</h3>
                                        <ul className="list-disc ml-4 space-y-1 text-xs">
                                            <li><b>Heatmap:</b> The floor colors show you what fits where. <b>Green</b> fits anything. <b>Light Red</b> fits Street/Spare. <b>Dark Red</b> only fits Spares.</li>
                                            <li><b>Zoom Panel:</b> Use the 1-9 grid to blow up a specific section of the lot to full size. This is vital for precision parking with Spare tires.</li>
                                            <li><b>Region Counters:</b> The numbers at the bottom tell you exactly how many valid placement points are left for each tire size.</li>
                                        </ul>
                                    </div>
                                </div>
                                <button onClick={() => setShowRules(false)} className="w-full mt-6 py-4 bg-white text-black font-bold rounded-xl active:scale-95 transition-transform uppercase italic">Return to Tournament</button>
                            </div>
                        </div>
                    )}

                    <div className="mb-2 text-center">
                        <h1 className="text-4xl lg:text-6xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-br from-yellow-400 via-orange-500 to-red-600 transform -skew-x-6 drop-shadow-xl">TIRED OUT</h1>
                    </div>

                    {gameState === 'setup' ? (
                        <div className="bg-neutral-900 p-6 rounded-3xl border border-neutral-800 w-full max-w-sm shadow-2xl">
                            <h2 className="text-xl font-bold mb-6 flex items-center gap-2 text-white"><IconSettings className="w-5 h-5 text-yellow-500" /> Lot Settings</h2>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-[10px] font-bold text-gray-500 uppercase block mb-2 tracking-widest">Opponent</label>
                                    <div className="flex bg-neutral-800 rounded-lg p-1 gap-1">
                                        <button onClick={() => setOpponentType('ai')} className={`flex-1 py-2 rounded-md text-xs font-bold transition-all ${opponentType === 'ai' ? 'bg-blue-600 text-white shadow-lg' : 'text-gray-500'}`}>AI BOT</button>
                                        <button onClick={() => setOpponentType('human')} className={`flex-1 py-2 rounded-md text-xs font-bold transition-all ${opponentType === 'human' ? 'bg-blue-600 text-white shadow-lg' : 'text-gray-500'}`}>HUMAN</button>
                                    </div>
                                </div>
                                {opponentType === 'ai' && (
                                    <div>
                                        <div className="flex justify-between items-center mb-1">
                                            <label className="text-[10px] font-bold text-gray-500 uppercase tracking-widest">AI Toughness</label>
                                            <span className="text-yellow-500 font-bold text-xs">{aiToughness === 10 ? 'ELITE' : aiToughness}</span>
                                        </div>
                                        <input type="range" min="1" max="10" value={aiToughness} onChange={e => setAiToughness(parseInt(e.target.value))} className="w-full h-1.5 bg-neutral-800 rounded-lg appearance-none cursor-pointer accent-yellow-500" />
                                    </div>
                                )}
                                <div className="grid grid-cols-2 gap-4">
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase block mb-1 tracking-widest text-center">Spare Tires</label>
                                        <div className="flex bg-neutral-800 rounded-lg p-1 gap-1">
                                            {[1, 2, 3].map(n => (<button key={n} onClick={() => setPebbleConfig(n)} className={`flex-1 py-1 rounded text-[10px] font-bold ${pebbleConfig === n ? 'bg-neutral-600 text-white' : 'text-gray-500'}`}>{n}</button>))}
                                        </div>
                                    </div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase block mb-1 tracking-widest text-center">Off-Road</label>
                                        <div className="flex bg-neutral-800 rounded-lg p-1 gap-1">
                                            {[1, 2, 3].map(n => (<button key={n} onClick={() => setBoulderConfig(n)} className={`flex-1 py-1 rounded text-[10px] font-bold ${boulderConfig === n ? 'bg-neutral-600 text-white' : 'text-gray-500'}`}>{n}</button>))}
                                        </div>
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 gap-4">
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase block mb-1">Match Length</label>
                                        <select value={matchLength} onChange={e => setMatchLength(parseInt(e.target.value))} className="w-full bg-neutral-800 p-2 rounded-lg text-[10px] font-bold text-white">
                                            {[1, 3, 5, 7, 9].map(n => <option key={n} value={n}>Best of {n}</option>)}
                                        </select>
                                    </div>
                                    <div><label className="text-[10px] font-bold text-gray-500 uppercase block mb-1">Lot Size</label>
                                        <select value={boardSize} onChange={e => setBoardSize(parseInt(e.target.value))} className="w-full bg-neutral-800 p-2 rounded-lg text-[10px] font-bold text-white">
                                            {[10, 15, 20].map(s => <option key={s} value={s}>{s}x{s}</option>)}
                                        </select>
                                    </div>
                                </div>
                                <button onClick={startMatch} className="w-full py-4 bg-gradient-to-r from-yellow-500 to-orange-600 rounded-xl font-black text-black text-lg uppercase italic shadow-xl active:scale-95 transition-transform">Open The Lot</button>
                                <button onClick={() => setShowRules(true)} className="w-full py-3 bg-neutral-800 text-gray-300 text-[10px] font-bold rounded-xl flex items-center justify-center gap-2 hover:bg-neutral-700 uppercase italic tracking-wider"><IconBook className="w-4 h-4 text-yellow-500"/> View Manual</button>
                            </div>
                        </div>
                    ) : (
                        <div className="flex flex-col lg:flex-row gap-6 items-center w-full max-w-5xl justify-center">
                            <div className="relative rounded-2xl overflow-hidden border-4 border-neutral-800 bg-neutral-900 shadow-2xl shrink-0" 
                                 style={{ width: (boardSize / view.factor) * scale, height: (boardSize / view.factor) * scale }}>
                                <canvas ref={heatMapCanvasRef} width={(boardSize / view.factor) * scale} height={(boardSize / view.factor) * scale} className="absolute inset-0 opacity-80" />
                                <canvas ref={canvasRef} width={(boardSize / view.factor) * scale} height={(boardSize / view.factor) * scale} 
                                    onMouseMove={e => updateGhost(e.clientX, e.clientY)}
                                    onTouchMove={e => updateGhost(e.touches[0].clientX, e.touches[0].clientY, true)}
                                    onMouseUp={attemptPlace} onTouchEnd={attemptPlace}
                                    className="absolute inset-0 z-10 cursor-crosshair touch-none" />
                                
                                {isAiThinking && (
                                    <div className="absolute top-4 right-4 z-50 bg-black/60 px-3 py-1.5 rounded-full flex items-center gap-2 border border-white/10 ai-pulse shadow-2xl">
                                        <IconCpu className="w-3 h-3 text-blue-400" />
                                        <span className="text-[10px] font-black text-white tracking-widest uppercase italic">AI Thinking...</span>
                                    </div>
                                )}

                                {(gameState === 'round_over' || gameState === 'match_over') && (
                                    <div className="absolute inset-0 z-50 bg-neutral-950/95 backdrop-blur-sm flex flex-col items-center justify-center p-6 text-center animate-in zoom-in duration-300">
                                        <IconTrophy className={`w-20 h-20 mb-4 animate-bounce-slow ${gameState === 'match_over' ? 'text-yellow-400' : 'text-gray-400'}`} />
                                        <h2 className="text-3xl font-black text-white italic mb-1 uppercase tracking-tighter">{gameState === 'match_over' ? 'Match Final' : 'Round Over'}</h2>
                                        <p className="text-lg text-gray-500 mb-8 font-bold italic">{getFinalMessage()}</p>
                                        <button onClick={gameState === 'match_over' ? () => setGameState('setup') : startRound} className="px-8 py-4 bg-white text-black font-black text-lg rounded-xl flex items-center justify-center gap-2 active:scale-95 transition-transform uppercase italic">
                                            {gameState === 'match_over' ? 'Main Menu' : 'Next Round'}
                                        </button>
                                    </div>
                                )}
                            </div>

                            <div className="w-full max-w-sm flex flex-col gap-3 shrink-0">
                                <div className="bg-neutral-800 p-3 rounded-xl flex justify-between items-center text-xs font-bold border border-neutral-700 shadow-xl">
                                    <span className="text-gray-500 uppercase tracking-widest">Score</span>
                                    <div className="flex gap-4 font-black">
                                        <span className="text-blue-500">P1: {scores.p1}</span>
                                        <span className="text-red-500">P2: {scores.p2}</span>
                                    </div>
                                </div>

                                <div className={`flex flex-col gap-2 p-3 rounded-xl border-2 transition-all ${currentPlayer === 1 && !isAiThinking ? 'border-yellow-400 bg-gray-800 scale-[1.03] shadow-2xl' : 'border-gray-800 bg-gray-900/50 opacity-40'}`}>
                                    <span className="font-black text-blue-500 uppercase flex items-center gap-2 italic tracking-tighter">Player 1</span>
                                    <div className="flex gap-2">
                                        {['unit', 'pebble', 'boulder'].map(type => (
                                            <button key={type} onClick={() => !isAiThinking && currentPlayer === 1 && setSelectedPiece(type)} className={`flex-1 flex flex-col items-center p-2 rounded-lg transition-all ${selectedPiece === type && currentPlayer === 1 ? 'bg-neutral-700 ring-2 ring-white' : 'bg-black/40'}`}>
                                                <div className={`rounded-full bg-gray-300 border-2 border-black/20 ${type === 'unit' ? 'w-6 h-6' : (type === 'pebble' ? 'w-4 h-4 my-1' : 'w-8 h-8 -my-1')}`} />
                                                <span className="text-[10px] font-black mt-1 text-gray-400 uppercase tracking-tighter">{type === 'unit' ? '∞' : (type === 'pebble' ? p1Inventory.pebbles : p1Inventory.boulders)}</span>
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className={`flex flex-col gap-2 p-3 rounded-xl border-2 transition-all ${currentPlayer === 2 || isAiThinking ? 'border-yellow-400 bg-gray-800 scale-[1.03] shadow-2xl' : 'border-gray-800 bg-gray-900/50 opacity-40'}`}>
                                    <span className="font-black text-red-500 uppercase flex items-center gap-2 italic tracking-tighter">{opponentType === 'ai' ? 'AI Bot' : 'Player 2'}</span>
                                    <div className="flex gap-2">
                                        {['unit', 'pebble', 'boulder'].map(type => (
                                            <div key={type} className={`flex-1 flex flex-col items-center p-2 rounded-lg bg-black/40`}>
                                                <div className={`rounded-full bg-gray-300 border-2 border-black/20 ${type === 'unit' ? 'w-6 h-6' : (type === 'pebble' ? 'w-4 h-4 my-1' : 'w-8 h-8 -my-1')}`} />
                                                <span className="text-[10px] font-black mt-1 text-gray-400 uppercase tracking-tighter">{type === 'unit' ? '∞' : (type === 'pebble' ? p2Inventory.pebbles : p2Inventory.boulders)}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <div className="bg-neutral-900 p-3 rounded-xl border border-neutral-800 flex items-center gap-4">
                                    <button onClick={() => setZoomIndex(zoomIndex ? null : 5)} 
                                            className={`p-4 rounded-xl border-2 transition-all ${zoomIndex ? 'bg-yellow-500 border-white text-black' : 'bg-neutral-800 border-neutral-700 text-gray-400'}`}>
                                        <IconSearch className="w-6 h-6" />
                                    </button>
                                    
                                    <div className="grid grid-cols-3 gap-1 flex-1">
                                        {[1,2,3,4,5,6,7,8,9].map(i => (
                                            <button key={i} onClick={() => setZoomIndex(i)} 
                                                    className={`h-8 text-xs font-black rounded-lg transition-all ${zoomIndex === i ? 'bg-blue-600 text-white shadow-lg ring-2 ring-white/20' : 'bg-neutral-800 text-gray-600 hover:text-gray-400'}`}>
                                                {i}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="grid grid-cols-3 gap-1 text-[8px] font-mono text-center uppercase tracking-tighter bg-neutral-950 p-2 rounded-lg border border-neutral-900">
                                    <div className="flex flex-col items-center gap-1 text-green-500"><div className="w-2 h-2 rounded-sm bg-[#1e3223]" /> OFF-ROAD: {Math.floor(regionCounts.offroad / 100)}</div>
                                    <div className="flex flex-col items-center gap-1 text-red-300"><div className="w-2 h-2 rounded-sm bg-[#8c5050]" /> STREET: {Math.floor(regionCounts.street / 100)}</div>
                                    <div className="flex flex-col items-center gap-1 text-red-600"><div className="w-2 h-2 rounded-sm bg-[#642828]" /> SPARE: {Math.floor(regionCounts.spare / 100)}</div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>
